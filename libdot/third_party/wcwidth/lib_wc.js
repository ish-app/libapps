// Copyright (c) 2014 The Chromium OS Authors. All rights reserved.
// Use of lib.wc source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

/**
 * @fileoverview
 * This JavaScript library is ported from the wcwidth.js module of node.js.
 * The original implementation can be found at:
 * https://npmjs.org/package/wcwidth.js
 */

/**
 * JavaScript porting of Markus Kuhn's wcwidth() implementation
 *
 * The following explanation comes from the original C implementation:
 *
 * This is an implementation of wcwidth() and wcswidth() (defined in
 * IEEE Std 1002.1-2001) for Unicode.
 *
 * https://www.opengroup.org/onlinepubs/007904975/functions/wcwidth.html
 * https://www.opengroup.org/onlinepubs/007904975/functions/wcswidth.html
 *
 * In fixed-width output devices, Latin characters all occupy a single
 * "cell" position of equal width, whereas ideographic CJK characters
 * occupy two such cells. Interoperability between terminal-line
 * applications and (teletype-style) character terminals using the
 * UTF-8 encoding requires agreement on which character should advance
 * the cursor by how many cell positions. No established formal
 * standards exist at present on which Unicode character shall occupy
 * how many cell positions on character terminals. These routines are
 * a first attempt of defining such behavior based on simple rules
 * applied to data provided by the Unicode Consortium.
 *
 * For some graphical characters, the Unicode standard explicitly
 * defines a character-cell width via the definition of the East Asian
 * FullWidth (F), Wide (W), Half-width (H), and Narrow (Na) classes.
 * In all these cases, there is no ambiguity about which width a
 * terminal shall use. For characters in the East Asian Ambiguous (A)
 * class, the width choice depends purely on a preference of backward
 * compatibility with either historic CJK or Western practice.
 * Choosing single-width for these characters is easy to justify as
 * the appropriate long-term solution, as the CJK practice of
 * displaying these characters as double-width comes from historic
 * implementation simplicity (8-bit encoded characters were displayed
 * single-width and 16-bit ones double-width, even for Greek,
 * Cyrillic, etc.) and not any typographic considerations.
 *
 * Much less clear is the choice of width for the Not East Asian
 * (Neutral) class. Existing practice does not dictate a width for any
 * of these characters. It would nevertheless make sense
 * typographically to allocate two character cells to characters such
 * as for instance EM SPACE or VOLUME INTEGRAL, which cannot be
 * represented adequately with a single-width glyph. The following
 * routines at present merely assign a single-cell width to all
 * neutral characters, in the interest of simplicity. This is not
 * entirely satisfactory and should be reconsidered before
 * establishing a formal standard in lib.wc area. At the moment, the
 * decision which Not East Asian (Neutral) characters should be
 * represented by double-width glyphs cannot yet be answered by
 * applying a simple rule from the Unicode database content. Setting
 * up a proper standard for the behavior of UTF-8 character terminals
 * will require a careful analysis not only of each Unicode character,
 * but also of each presentation form, something the author of these
 * routines has avoided to do so far.
 *
 * https://www.unicode.org/unicode/reports/tr11/
 *
 * Markus Kuhn -- 2007-05-26 (Unicode 5.0)
 *
 * Permission to use, copy, modify, and distribute lib.wc software
 * for any purpose and without fee is hereby granted. The author
 * disclaims all warranties with regard to lib.wc software.
 *
 * Latest version: https://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c
 */

/**
 * The following function defines the column width of an ISO 10646 character
 * as follows:
 *
 *  - The null character (U+0000) has a column width of 0.
 *  - Other C0/C1 control characters and DEL will lead to a return value of -1.
 *  - Non-spacing and enclosing combining characters (general category code Mn
 *    or Me in the Unicode database) have a column width of 0.
 *  - SOFT HYPHEN (U+00AD) has a column width of 1.
 *  - Other format characters (general category code Cf in the Unicode database)
 *    and ZERO WIDTH SPACE (U+200B) have a column width of 0.
 *  - Hangul Jamo medial vowels and final consonants (U+1160-U+11FF) have a
 *    column width of 0.
 *  - Spacing characters in the East Asian Wide (W) or East Asian Full-width (F)
 *    category as defined in Unicode Technical Report #11 have a column width of
 *    2.
 *  - East Asian Ambiguous characters are taken into account if
 *    regardCjkAmbiguous flag is enabled. They have a column width of 2.
 *  - All remaining characters (including all printable ISO 8859-1 and WGL4
 *    characters, Unicode control characters, etc.) have a column width of 1.
 *
 * This implementation assumes that characters are encoded in ISO 10646.
 */

lib.wc = {};

// Width of a nul character.
lib.wc.nulWidth = 0;

// Width of a control character.
lib.wc.controlWidth = 0;

// Flag whether to consider East Asian Ambiguous characters.
lib.wc.regardCjkAmbiguous = false;

// Width of an East Asian Ambiguous character.
lib.wc.cjkAmbiguousWidth = 2;

// Sorted list of non-overlapping intervals of non-spacing characters
// pulled from EastAsianWidth.txt, UnicodeData.txt, and emoji-data.txt
lib.wc.combining = [
  [0x00300, 0x0036f], [0x00483, 0x00489], [0x00591, 0x005bd], [0x005bf, 0x005bf],
  [0x005c1, 0x005c2], [0x005c4, 0x005c5], [0x005c7, 0x005c7], [0x00610, 0x0061a],
  [0x0064b, 0x0065f], [0x00670, 0x00670], [0x006d6, 0x006dc], [0x006df, 0x006e4],
  [0x006e7, 0x006e8], [0x006ea, 0x006ed], [0x00711, 0x00711], [0x00730, 0x0074a],
  [0x007a6, 0x007b0], [0x007eb, 0x007f3], [0x007fd, 0x007fd], [0x00816, 0x00819],
  [0x0081b, 0x00823], [0x00825, 0x00827], [0x00829, 0x0082d], [0x00859, 0x0085b],
  [0x00898, 0x0089f], [0x008ca, 0x008e1], [0x008e3, 0x00903], [0x0093a, 0x0093c],
  [0x0093e, 0x0094f], [0x00951, 0x00957], [0x00962, 0x00963], [0x00981, 0x00983],
  [0x009bc, 0x009bc], [0x009be, 0x009c4], [0x009c7, 0x009c8], [0x009cb, 0x009cd],
  [0x009d7, 0x009d7], [0x009e2, 0x009e3], [0x009fe, 0x009fe], [0x00a01, 0x00a03],
  [0x00a3c, 0x00a3c], [0x00a3e, 0x00a42], [0x00a47, 0x00a48], [0x00a4b, 0x00a4d],
  [0x00a51, 0x00a51], [0x00a70, 0x00a71], [0x00a75, 0x00a75], [0x00a81, 0x00a83],
  [0x00abc, 0x00abc], [0x00abe, 0x00ac5], [0x00ac7, 0x00ac9], [0x00acb, 0x00acd],
  [0x00ae2, 0x00ae3], [0x00afa, 0x00aff], [0x00b01, 0x00b03], [0x00b3c, 0x00b3c],
  [0x00b3e, 0x00b44], [0x00b47, 0x00b48], [0x00b4b, 0x00b4d], [0x00b55, 0x00b57],
  [0x00b62, 0x00b63], [0x00b82, 0x00b82], [0x00bbe, 0x00bc2], [0x00bc6, 0x00bc8],
  [0x00bca, 0x00bcd], [0x00bd7, 0x00bd7], [0x00c00, 0x00c04], [0x00c3c, 0x00c3c],
  [0x00c3e, 0x00c44], [0x00c46, 0x00c48], [0x00c4a, 0x00c4d], [0x00c55, 0x00c56],
  [0x00c62, 0x00c63], [0x00c81, 0x00c83], [0x00cbc, 0x00cbc], [0x00cbe, 0x00cc4],
  [0x00cc6, 0x00cc8], [0x00cca, 0x00ccd], [0x00cd5, 0x00cd6], [0x00ce2, 0x00ce3],
  [0x00d00, 0x00d03], [0x00d3b, 0x00d3c], [0x00d3e, 0x00d44], [0x00d46, 0x00d48],
  [0x00d4a, 0x00d4d], [0x00d57, 0x00d57], [0x00d62, 0x00d63], [0x00d81, 0x00d83],
  [0x00dca, 0x00dca], [0x00dcf, 0x00dd4], [0x00dd6, 0x00dd6], [0x00dd8, 0x00ddf],
  [0x00df2, 0x00df3], [0x00e31, 0x00e31], [0x00e34, 0x00e3a], [0x00e47, 0x00e4e],
  [0x00eb1, 0x00eb1], [0x00eb4, 0x00ebc], [0x00ec8, 0x00ecd], [0x00f18, 0x00f19],
  [0x00f35, 0x00f35], [0x00f37, 0x00f37], [0x00f39, 0x00f39], [0x00f3e, 0x00f3f],
  [0x00f71, 0x00f84], [0x00f86, 0x00f87], [0x00f8d, 0x00f97], [0x00f99, 0x00fbc],
  [0x00fc6, 0x00fc6], [0x0102b, 0x0103e], [0x01056, 0x01059], [0x0105e, 0x01060],
  [0x01062, 0x01064], [0x01067, 0x0106d], [0x01071, 0x01074], [0x01082, 0x0108d],
  [0x0108f, 0x0108f], [0x0109a, 0x0109d], [0x0135d, 0x0135f], [0x01712, 0x01715],
  [0x01732, 0x01734], [0x01752, 0x01753], [0x01772, 0x01773], [0x017b4, 0x017d3],
  [0x017dd, 0x017dd], [0x0180b, 0x0180d], [0x0180f, 0x0180f], [0x01885, 0x01886],
  [0x018a9, 0x018a9], [0x01920, 0x0192b], [0x01930, 0x0193b], [0x01a17, 0x01a1b],
  [0x01a55, 0x01a5e], [0x01a60, 0x01a7c], [0x01a7f, 0x01a7f], [0x01ab0, 0x01ace],
  [0x01b00, 0x01b04], [0x01b34, 0x01b44], [0x01b6b, 0x01b73], [0x01b80, 0x01b82],
  [0x01ba1, 0x01bad], [0x01be6, 0x01bf3], [0x01c24, 0x01c37], [0x01cd0, 0x01cd2],
  [0x01cd4, 0x01ce8], [0x01ced, 0x01ced], [0x01cf4, 0x01cf4], [0x01cf7, 0x01cf9],
  [0x01dc0, 0x01dff], [0x020d0, 0x020f0], [0x02cef, 0x02cf1], [0x02d7f, 0x02d7f],
  [0x02de0, 0x02dff], [0x0302a, 0x0302f], [0x03099, 0x0309a], [0x0a66f, 0x0a672],
  [0x0a674, 0x0a67d], [0x0a69e, 0x0a69f], [0x0a6f0, 0x0a6f1], [0x0a802, 0x0a802],
  [0x0a806, 0x0a806], [0x0a80b, 0x0a80b], [0x0a823, 0x0a827], [0x0a82c, 0x0a82c],
  [0x0a880, 0x0a881], [0x0a8b4, 0x0a8c5], [0x0a8e0, 0x0a8f1], [0x0a8ff, 0x0a8ff],
  [0x0a926, 0x0a92d], [0x0a947, 0x0a953], [0x0a980, 0x0a983], [0x0a9b3, 0x0a9c0],
  [0x0a9e5, 0x0a9e5], [0x0aa29, 0x0aa36], [0x0aa43, 0x0aa43], [0x0aa4c, 0x0aa4d],
  [0x0aa7b, 0x0aa7d], [0x0aab0, 0x0aab0], [0x0aab2, 0x0aab4], [0x0aab7, 0x0aab8],
  [0x0aabe, 0x0aabf], [0x0aac1, 0x0aac1], [0x0aaeb, 0x0aaef], [0x0aaf5, 0x0aaf6],
  [0x0abe3, 0x0abea], [0x0abec, 0x0abed], [0x0fb1e, 0x0fb1e], [0x0fe00, 0x0fe0f],
  [0x0fe20, 0x0fe2f], [0x101fd, 0x101fd], [0x102e0, 0x102e0], [0x10376, 0x1037a],
  [0x10a01, 0x10a03], [0x10a05, 0x10a06], [0x10a0c, 0x10a0f], [0x10a38, 0x10a3a],
  [0x10a3f, 0x10a3f], [0x10ae5, 0x10ae6], [0x10d24, 0x10d27], [0x10eab, 0x10eac],
  [0x10f46, 0x10f50], [0x10f82, 0x10f85], [0x11000, 0x11002], [0x11038, 0x11046],
  [0x11070, 0x11070], [0x11073, 0x11074], [0x1107f, 0x11082], [0x110b0, 0x110ba],
  [0x110c2, 0x110c2], [0x11100, 0x11102], [0x11127, 0x11134], [0x11145, 0x11146],
  [0x11173, 0x11173], [0x11180, 0x11182], [0x111b3, 0x111c0], [0x111c9, 0x111cc],
  [0x111ce, 0x111cf], [0x1122c, 0x11237], [0x1123e, 0x1123e], [0x112df, 0x112ea],
  [0x11300, 0x11303], [0x1133b, 0x1133c], [0x1133e, 0x11344], [0x11347, 0x11348],
  [0x1134b, 0x1134d], [0x11357, 0x11357], [0x11362, 0x11363], [0x11366, 0x1136c],
  [0x11370, 0x11374], [0x11435, 0x11446], [0x1145e, 0x1145e], [0x114b0, 0x114c3],
  [0x115af, 0x115b5], [0x115b8, 0x115c0], [0x115dc, 0x115dd], [0x11630, 0x11640],
  [0x116ab, 0x116b7], [0x1171d, 0x1172b], [0x1182c, 0x1183a], [0x11930, 0x11935],
  [0x11937, 0x11938], [0x1193b, 0x1193e], [0x11940, 0x11940], [0x11942, 0x11943],
  [0x119d1, 0x119d7], [0x119da, 0x119e0], [0x119e4, 0x119e4], [0x11a01, 0x11a0a],
  [0x11a33, 0x11a39], [0x11a3b, 0x11a3e], [0x11a47, 0x11a47], [0x11a51, 0x11a5b],
  [0x11a8a, 0x11a99], [0x11c2f, 0x11c36], [0x11c38, 0x11c3f], [0x11c92, 0x11ca7],
  [0x11ca9, 0x11cb6], [0x11d31, 0x11d36], [0x11d3a, 0x11d3a], [0x11d3c, 0x11d3d],
  [0x11d3f, 0x11d45], [0x11d47, 0x11d47], [0x11d8a, 0x11d8e], [0x11d90, 0x11d91],
  [0x11d93, 0x11d97], [0x11ef3, 0x11ef6], [0x16af0, 0x16af4], [0x16b30, 0x16b36],
  [0x16f4f, 0x16f4f], [0x16f51, 0x16f87], [0x16f8f, 0x16f92], [0x16fe4, 0x16fe4],
  [0x16ff0, 0x16ff1], [0x1bc9d, 0x1bc9e], [0x1cf00, 0x1cf2d], [0x1cf30, 0x1cf46],
  [0x1d165, 0x1d169], [0x1d16d, 0x1d172], [0x1d17b, 0x1d182], [0x1d185, 0x1d18b],
  [0x1d1aa, 0x1d1ad], [0x1d242, 0x1d244], [0x1da00, 0x1da36], [0x1da3b, 0x1da6c],
  [0x1da75, 0x1da75], [0x1da84, 0x1da84], [0x1da9b, 0x1da9f], [0x1daa1, 0x1daaf],
  [0x1e000, 0x1e006], [0x1e008, 0x1e018], [0x1e01b, 0x1e021], [0x1e023, 0x1e024],
  [0x1e026, 0x1e02a], [0x1e130, 0x1e136], [0x1e2ae, 0x1e2ae], [0x1e2ec, 0x1e2ef],
  [0x1e8d0, 0x1e8d6], [0x1e944, 0x1e94a], [0xe0100, 0xe01ef]
];

// Sorted list of non-overlapping intervals of East Asian Ambiguous characters
// pulled from EastAsianWidth.txt, UnicodeData.txt, and emoji-data.txt
lib.wc.ambiguous = [
  [0x000a1, 0x000a1], [0x000a4, 0x000a4], [0x000a7, 0x000a8], [0x000aa, 0x000aa],
  [0x000ad, 0x000ae], [0x000b0, 0x000b4], [0x000b6, 0x000ba], [0x000bc, 0x000bf],
  [0x000c6, 0x000c6], [0x000d0, 0x000d0], [0x000d7, 0x000d8], [0x000de, 0x000e1],
  [0x000e6, 0x000e6], [0x000e8, 0x000ea], [0x000ec, 0x000ed], [0x000f0, 0x000f0],
  [0x000f2, 0x000f3], [0x000f7, 0x000fa], [0x000fc, 0x000fc], [0x000fe, 0x000fe],
  [0x00101, 0x00101], [0x00111, 0x00111], [0x00113, 0x00113], [0x0011b, 0x0011b],
  [0x00126, 0x00127], [0x0012b, 0x0012b], [0x00131, 0x00133], [0x00138, 0x00138],
  [0x0013f, 0x00142], [0x00144, 0x00144], [0x00148, 0x0014b], [0x0014d, 0x0014d],
  [0x00152, 0x00153], [0x00166, 0x00167], [0x0016b, 0x0016b], [0x001ce, 0x001ce],
  [0x001d0, 0x001d0], [0x001d2, 0x001d2], [0x001d4, 0x001d4], [0x001d6, 0x001d6],
  [0x001d8, 0x001d8], [0x001da, 0x001da], [0x001dc, 0x001dc], [0x00251, 0x00251],
  [0x00261, 0x00261], [0x002c4, 0x002c4], [0x002c7, 0x002c7], [0x002c9, 0x002cb],
  [0x002cd, 0x002cd], [0x002d0, 0x002d0], [0x002d8, 0x002db], [0x002dd, 0x002dd],
  [0x002df, 0x002df], [0x00300, 0x0036f], [0x00391, 0x003a1], [0x003a3, 0x003a9],
  [0x003b1, 0x003c1], [0x003c3, 0x003c9], [0x00401, 0x00401], [0x00410, 0x0044f],
  [0x00451, 0x00451], [0x02010, 0x02010], [0x02013, 0x02016], [0x02018, 0x02019],
  [0x0201c, 0x0201d], [0x02020, 0x02022], [0x02024, 0x02027], [0x02030, 0x02030],
  [0x02032, 0x02033], [0x02035, 0x02035], [0x0203b, 0x0203b], [0x0203e, 0x0203e],
  [0x02074, 0x02074], [0x0207f, 0x0207f], [0x02081, 0x02084], [0x020ac, 0x020ac],
  [0x02103, 0x02103], [0x02105, 0x02105], [0x02109, 0x02109], [0x02113, 0x02113],
  [0x02116, 0x02116], [0x02121, 0x02122], [0x02126, 0x02126], [0x0212b, 0x0212b],
  [0x02153, 0x02154], [0x0215b, 0x0215e], [0x02160, 0x0216b], [0x02170, 0x02179],
  [0x02189, 0x02189], [0x02190, 0x02199], [0x021b8, 0x021b9], [0x021d2, 0x021d2],
  [0x021d4, 0x021d4], [0x021e7, 0x021e7], [0x02200, 0x02200], [0x02202, 0x02203],
  [0x02207, 0x02208], [0x0220b, 0x0220b], [0x0220f, 0x0220f], [0x02211, 0x02211],
  [0x02215, 0x02215], [0x0221a, 0x0221a], [0x0221d, 0x02220], [0x02223, 0x02223],
  [0x02225, 0x02225], [0x02227, 0x0222c], [0x0222e, 0x0222e], [0x02234, 0x02237],
  [0x0223c, 0x0223d], [0x02248, 0x02248], [0x0224c, 0x0224c], [0x02252, 0x02252],
  [0x02260, 0x02261], [0x02264, 0x02267], [0x0226a, 0x0226b], [0x0226e, 0x0226f],
  [0x02282, 0x02283], [0x02286, 0x02287], [0x02295, 0x02295], [0x02299, 0x02299],
  [0x022a5, 0x022a5], [0x022bf, 0x022bf], [0x02312, 0x02312], [0x02460, 0x024e9],
  [0x024eb, 0x0254b], [0x02550, 0x02573], [0x02580, 0x0258f], [0x02592, 0x02595],
  [0x025a0, 0x025a1], [0x025a3, 0x025a9], [0x025b2, 0x025b3], [0x025b6, 0x025b7],
  [0x025bc, 0x025bd], [0x025c0, 0x025c1], [0x025c6, 0x025c8], [0x025cb, 0x025cb],
  [0x025ce, 0x025d1], [0x025e2, 0x025e5], [0x025ef, 0x025ef], [0x02605, 0x02606],
  [0x02609, 0x02609], [0x0260e, 0x0260f], [0x0261c, 0x0261c], [0x0261e, 0x0261e],
  [0x02640, 0x02640], [0x02642, 0x02642], [0x02660, 0x02661], [0x02663, 0x02665],
  [0x02667, 0x0266a], [0x0266c, 0x0266d], [0x0266f, 0x0266f], [0x0269e, 0x0269f],
  [0x026bf, 0x026bf], [0x026c6, 0x026cd], [0x026cf, 0x026d3], [0x026d5, 0x026e1],
  [0x026e3, 0x026e3], [0x026e8, 0x026e9], [0x026eb, 0x026f1], [0x026f4, 0x026f4],
  [0x026f6, 0x026f9], [0x026fb, 0x026fc], [0x026fe, 0x026ff], [0x0273d, 0x0273d],
  [0x02776, 0x0277f], [0x02b56, 0x02b59], [0x03248, 0x0324f], [0x0e000, 0x0f8ff],
  [0x0fe00, 0x0fe0f], [0x0fffd, 0x0fffd], [0x1f100, 0x1f10a], [0x1f110, 0x1f12d],
  [0x1f130, 0x1f169], [0x1f170, 0x1f18d], [0x1f18f, 0x1f190], [0x1f19b, 0x1f1ac],
  [0xe0100, 0xe01ef], [0xf0000, 0xffffd], [0x100000, 0x10fffd]
];

// Sorted list of non-overlapping intervals of East Asian Unambiguous characters
// pulled from EastAsianWidth.txt, UnicodeData.txt, and emoji-data.txt
lib.wc.unambiguous = [
  [0x01100, 0x0115f], [0x0231a, 0x0231b], [0x02329, 0x0232a], [0x023e9, 0x023ec],
  [0x023f0, 0x023f0], [0x023f3, 0x023f3], [0x025fd, 0x025fe], [0x02614, 0x02615],
  [0x02648, 0x02653], [0x0267f, 0x0267f], [0x02693, 0x02693], [0x026a1, 0x026a1],
  [0x026aa, 0x026ab], [0x026bd, 0x026be], [0x026c4, 0x026c5], [0x026ce, 0x026ce],
  [0x026d4, 0x026d4], [0x026ea, 0x026ea], [0x026f2, 0x026f3], [0x026f5, 0x026f5],
  [0x026fa, 0x026fa], [0x026fd, 0x026fd], [0x02705, 0x02705], [0x0270a, 0x0270b],
  [0x02728, 0x02728], [0x0274c, 0x0274c], [0x0274e, 0x0274e], [0x02753, 0x02755],
  [0x02757, 0x02757], [0x02795, 0x02797], [0x027b0, 0x027b0], [0x027bf, 0x027bf],
  [0x02b1b, 0x02b1c], [0x02b50, 0x02b50], [0x02b55, 0x02b55], [0x02e80, 0x02e99],
  [0x02e9b, 0x02ef3], [0x02f00, 0x02fd5], [0x02ff0, 0x02ffb], [0x03000, 0x0303e],
  [0x03041, 0x03096], [0x03099, 0x030ff], [0x03105, 0x0312f], [0x03131, 0x0318e],
  [0x03190, 0x031e3], [0x031f0, 0x0321e], [0x03220, 0x03247], [0x03250, 0x04dbf],
  [0x04e00, 0x0a48c], [0x0a490, 0x0a4c6], [0x0a960, 0x0a97c], [0x0ac00, 0x0d7a3],
  [0x0f900, 0x0faff], [0x0fe10, 0x0fe19], [0x0fe30, 0x0fe52], [0x0fe54, 0x0fe66],
  [0x0fe68, 0x0fe6b], [0x0ff01, 0x0ff60], [0x0ffe0, 0x0ffe6], [0x16fe0, 0x16fe4],
  [0x16ff0, 0x16ff1], [0x17000, 0x187f7], [0x18800, 0x18cd5], [0x18d00, 0x18d08],
  [0x1aff0, 0x1aff3], [0x1aff5, 0x1affb], [0x1affd, 0x1affe], [0x1b000, 0x1b122],
  [0x1b150, 0x1b152], [0x1b164, 0x1b167], [0x1b170, 0x1b2fb], [0x1f004, 0x1f004],
  [0x1f0cf, 0x1f0cf], [0x1f18e, 0x1f18e], [0x1f191, 0x1f19a], [0x1f200, 0x1f202],
  [0x1f210, 0x1f23b], [0x1f240, 0x1f248], [0x1f250, 0x1f251], [0x1f260, 0x1f265],
  [0x1f300, 0x1f320], [0x1f32d, 0x1f335], [0x1f337, 0x1f37c], [0x1f37e, 0x1f393],
  [0x1f3a0, 0x1f3ca], [0x1f3cf, 0x1f3d3], [0x1f3e0, 0x1f3f0], [0x1f3f4, 0x1f3f4],
  [0x1f3f8, 0x1f43e], [0x1f440, 0x1f440], [0x1f442, 0x1f4fc], [0x1f4ff, 0x1f53d],
  [0x1f54b, 0x1f54e], [0x1f550, 0x1f567], [0x1f57a, 0x1f57a], [0x1f595, 0x1f596],
  [0x1f5a4, 0x1f5a4], [0x1f5fb, 0x1f64f], [0x1f680, 0x1f6c5], [0x1f6cc, 0x1f6cc],
  [0x1f6d0, 0x1f6d2], [0x1f6d5, 0x1f6d7], [0x1f6dd, 0x1f6df], [0x1f6eb, 0x1f6ec],
  [0x1f6f4, 0x1f6fc], [0x1f7e0, 0x1f7eb], [0x1f7f0, 0x1f7f0], [0x1f90c, 0x1f93a],
  [0x1f93c, 0x1f945], [0x1f947, 0x1f9ff], [0x1fa70, 0x1fa74], [0x1fa78, 0x1fa7c],
  [0x1fa80, 0x1fa86], [0x1fa90, 0x1faac], [0x1fab0, 0x1faba], [0x1fac0, 0x1fac5],
  [0x1fad0, 0x1fad9], [0x1fae0, 0x1fae7], [0x1faf0, 0x1faf6], [0x20000, 0x2fffd],
  [0x30000, 0x3fffd]
];

/**
 * Binary search to check if the given unicode character is in the table.
 *
 * @param {number} ucs A unicode character code.
 * @param {!Array<!Array<number>>} table A sorted list of internals to match
 *     against.
 * @return {boolean} True if the given character is in the table.
 */
lib.wc.binaryTableSearch_ = function(ucs, table) {
  let min = 0;
  let max = table.length - 1;
  let mid;

  if (ucs < table[min][0] || ucs > table[max][1]) {
    return false;
  }
  while (max >= min) {
    mid = Math.floor((min + max) / 2);
    if (ucs > table[mid][1]) {
      min = mid + 1;
    } else if (ucs < table[mid][0]) {
      max = mid - 1;
    } else {
      return true;
    }
  }

  return false;
};

/**
 * Binary search to check if the given unicode character is a space character.
 *
 * @param {number} ucs A unicode character code.
 * @return {boolean} True if the given character is a space character; false
 *     otherwise.
 */
lib.wc.isSpace = function(ucs) {
  return lib.wc.binaryTableSearch_(ucs, lib.wc.combining);
};

/**
 * Auxiliary function for checking if the given unicode character is a East
 * Asian Ambiguous character.
 *
 * @param {number} ucs A unicode character code.
 * @return {boolean} True if the given character is a East Asian Ambiguous
 *     character.
 */
lib.wc.isCjkAmbiguous = function(ucs) {
  return lib.wc.binaryTableSearch_(ucs, lib.wc.ambiguous);
};

/**
 * Determine the column width of the given character.
 *
 * @param {number} ucs A unicode character code.
 * @return {number} The column width of the given character.
 */
lib.wc.charWidth = function(ucs) {
  if (lib.wc.regardCjkAmbiguous) {
    return lib.wc.charWidthRegardAmbiguous(ucs);
  } else {
    return lib.wc.charWidthDisregardAmbiguous(ucs);
  }
};

/**
 * Determine the column width of the given character without considering East
 * Asian Ambiguous characters.
 *
 * @param {number} ucs A unicode character code.
 * @return {number} The column width of the given character.
 */
lib.wc.charWidthDisregardAmbiguous = function(ucs) {
  // Optimize for ASCII characters.
  if (ucs < 0x7f) {
    if (ucs >= 0x20) {
      return 1;
    } else if (ucs == 0) {
      return lib.wc.nulWidth;
    } else /* if (ucs < 0x20) */ {
      return lib.wc.controlWidth;
    }
  }

  // Test for 8-bit control characters.
  if (ucs < 0xa0) {
    return lib.wc.controlWidth;
  }

  // Binary search in table of non-spacing characters.
  if (lib.wc.isSpace(ucs)) {
    return 0;
  }

  // Binary search in table of wide characters.
  return lib.wc.binaryTableSearch_(ucs, lib.wc.unambiguous) ? 2 : 1;
};

/**
 * Determine the column width of the given character considering East Asian
 * Ambiguous characters.
 *
 * @param {number} ucs A unicode character code.
 * @return {number} The column width of the given character.
 */
lib.wc.charWidthRegardAmbiguous = function(ucs) {
  if (lib.wc.isCjkAmbiguous(ucs)) {
    return lib.wc.cjkAmbiguousWidth;
  }

  return lib.wc.charWidthDisregardAmbiguous(ucs);
};

/**
 * Determine the column width of the given string.
 *
 * @param {string} str A string.
 * @return {number} The column width of the given string.
 */
lib.wc.strWidth = function(str) {
  let rv = 0;

  for (let i = 0; i < str.length;) {
    const codePoint = str.codePointAt(i);
    const width = lib.wc.charWidth(codePoint);
    if (width < 0) {
      return -1;
    }
    rv += width;
    i += (codePoint <= 0xffff) ? 1 : 2;
  }

  return rv;
};

/**
 * Get the substring at the given column offset of the given column width.
 *
 * @param {string} str The string to get substring from.
 * @param {number} start The starting column offset to get substring.
 * @param {number=} subwidth The column width of the substring.
 * @return {string} The substring.
 */
lib.wc.substr = function(str, start, subwidth = undefined) {
  let startIndex = 0;

  // Fun edge case: Normally we associate zero width codepoints (like combining
  // characters) with the previous codepoint, so we skip any leading ones while
  // including trailing ones.  However, if there are zero width codepoints at
  // the start of the string, and the substring starts at 0, lets include them
  // in the result.  This also makes for a simple optimization for a common
  // request.
  if (start) {
    for (let width = 0; startIndex < str.length;) {
      const codePoint = str.codePointAt(startIndex);
      width += lib.wc.charWidth(codePoint);
      if (width > start) {
        break;
      }
      startIndex += (codePoint <= 0xffff) ? 1 : 2;
    }
  }

  if (subwidth !== undefined) {
    let endIndex = startIndex;
    for (let width = 0; endIndex < str.length;) {
      const codePoint = str.codePointAt(endIndex);
      width += lib.wc.charWidth(codePoint);
      if (width > subwidth) {
        break;
      }
      endIndex += (codePoint <= 0xffff) ? 1 : 2;
    }
    return str.substring(startIndex, endIndex);
  }

  return str.substr(startIndex);
};

/**
 * Get substring at the given start and end column offset.
 *
 * @param {string} str The string to get substring from.
 * @param {number} start The starting column offset.
 * @param {number} end The ending column offset.
 * @return {string} The substring.
 */
lib.wc.substring = function(str, start, end) {
  return lib.wc.substr(str, start, end - start);
};
